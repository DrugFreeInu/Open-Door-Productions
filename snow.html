<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DFI Snow Scene</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
      touch-action: none;
    }

    /* ===== Viewport ===== */
    .viewport {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    /* ===== Image pan layer ===== */
    .pan-layer {
      position: absolute;
      top: 0;
      left: 0;
      height: 100vh;
      will-change: transform;
      transform: translateX(0);
      cursor: grab;
    }
    .pan-layer:active { cursor: grabbing; }

    .bg-image {
      height: 100vh;
      width: auto;
      display: block;
      user-select: none;
      pointer-events: none;
    }

    /* ===== Snow overlay (fixed to screen) ===== */
    #snow-canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>

<body>
  <!-- Image scene -->
  <div class="viewport">
    <div class="pan-layer" id="pan">
      <img
        class="bg-image"
        id="bg"
        src="E85291DD-8424-44F6-B1B1-B6FA7CEAB9E0.png"
        draggable="false"
        alt=""
      />
    </div>
  </div>

  <!-- Snow overlay -->
  <canvas id="snow-canvas"></canvas>

  <script>
    /* ======================
       SETUP
    ====================== */
    const pan = document.getElementById("pan");
    const img = document.getElementById("bg");

    const canvas = document.getElementById("snow-canvas");
    const ctx = canvas.getContext("2d");

    let viewW = window.innerWidth;
    let viewH = window.innerHeight;
    let sceneWidth = 0;

    // Pan state
    let x = 0;          // committed pan
    let currentX = 0;   // actual pan shown (includes live drag)
    let startX = 0;
    let dragging = false;

    function measureSceneWidth() {
      // Displayed width of the panorama at height: 100vh
      const w = img.getBoundingClientRect().width;
      if (w) sceneWidth = w;
    }

    function clampPan(nx) {
      // Keep the image within bounds (no black gaps)
      if (!sceneWidth || sceneWidth <= viewW) return 0;
      const minX = viewW - sceneWidth; // negative
      const maxX = 0;
      return Math.min(maxX, Math.max(minX, nx));
    }

    function setPan(nx) {
      currentX = clampPan(nx);
      pan.style.transform = `translateX(${currentX}px)`;
    }

    /* ======================
       PAN CONTROLS
    ====================== */
    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      x = clampPan(x - e.deltaY);
      setPan(x);
    }, { passive: false });

    window.addEventListener("touchstart", (e) => {
      dragging = true;
      startX = e.touches[0].clientX;
    }, { passive: true });

    window.addEventListener("touchmove", (e) => {
      if (!dragging) return;
      const dx = e.touches[0].clientX - startX;
      setPan(x + dx);
    }, { passive: true });

    window.addEventListener("touchend", (e) => {
      if (!dragging) return;
      const dx = e.changedTouches[0].clientX - startX;
      x = clampPan(x + dx);
      setPan(x);
      dragging = false;
    });

    /* ======================
       WORLD-WIDTH SNOW
       (particles exist across the full image width,
        but we render only the viewport slice)
    ====================== */
    let particles = [];
    const BASE_COUNT = 150;   // ~flakes visible per screen
    const MAX_COUNT  = 1500;  // safety cap for performance

    function initParticles() {
      if (!sceneWidth) return;

      // Keep density roughly constant no matter how wide the world is
      const count = Math.min(
        MAX_COUNT,
        Math.max(BASE_COUNT, Math.round(BASE_COUNT * (sceneWidth / viewW)))
      );

      particles = Array.from({ length: count }, () => ({
        x: Math.random() * sceneWidth,   // WORLD X (0..sceneWidth)
        y: Math.random() * viewH,
        r: Math.random() * 2 + 1,
        d: Math.random() * 1 + 0.5
      }));
    }

    function resizeAll() {
      viewW = window.innerWidth;
      viewH = window.innerHeight;

      // Retina-safe canvas
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.round(viewW * dpr);
      canvas.height = Math.round(viewH * dpr);
      canvas.style.width  = viewW + "px";
      canvas.style.height = viewH + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Re-measure panorama width (depends on 100vh)
      measureSceneWidth();

      // Clamp pan to new bounds
      x = clampPan(x);
      setPan(x);

      // Rebuild snow for correct density
      initParticles();
    }

    window.addEventListener("resize", resizeAll);

    function drawSnow() {
      ctx.clearRect(0, 0, viewW, viewH);
      ctx.fillStyle = "white";
      ctx.beginPath();

      const margin = 10;

      for (const p of particles) {
        // WORLD -> SCREEN (key line)
        const sx = p.x + currentX;

        // Only draw whatâ€™s in/near the viewport
        if (sx >= -margin && sx <= viewW + margin) {
          ctx.moveTo(sx, p.y);
          ctx.arc(sx, p.y, p.r, 0, Math.PI * 2);
        }

        // Fall
        p.y += p.d;

        // Respawn at top, anywhere in the WORLD width
        if (p.y > viewH + margin) {
          p.y = -margin;
          p.x = Math.random() * sceneWidth;
        }
      }

      ctx.fill();
      requestAnimationFrame(drawSnow);
    }

    // Start once the image has real dimensions
    function start() {
      // run on next frame to ensure layout is ready
      requestAnimationFrame(() => {
        resizeAll();
        drawSnow();
      });
    }

    if (img.complete && img.naturalWidth) start();
    else img.addEventListener("load", start);
  </script>
</body>
</html>
