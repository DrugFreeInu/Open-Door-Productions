<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DFI Snow Scene</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
      touch-action: none;
    }

    .viewport {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    .pan-layer {
      position: absolute;
      top: 0;
      left: 0;
      height: 100vh;
      will-change: transform;
      transform: translateX(0);
      cursor: grab;
    }
    .pan-layer:active { cursor: grabbing; }

    .bg-image {
      height: 100vh;
      width: auto;
      display: block;
      user-select: none;
      pointer-events: none;
    }

    #snow-canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>

<body>

  <div class="viewport">
    <div class="pan-layer" id="pan">
      <img
        class="bg-image"
        id="bg"
        src="E85291DD-8424-44F6-B1B1-B6FA7CEAB9E0.png"
        draggable="false"
        alt=""
      />
    </div>
  </div>

  <canvas id="snow-canvas"></canvas>

  <script>
    const pan = document.getElementById("pan");
    const img = document.getElementById("bg");
    const canvas = document.getElementById("snow-canvas");
    const ctx = canvas.getContext("2d");

    let viewW = window.innerWidth;
    let viewH = window.innerHeight;
    let sceneWidth = 0;

    let x = 0;
    let currentX = 0;
    let startX = 0;
    let dragging = false;

    function measureSceneWidth() {
      const w = img.getBoundingClientRect().width;
      if (w) sceneWidth = w;
    }

    function clampPan(nx) {
      if (!sceneWidth || sceneWidth <= viewW) return 0;
      const minX = viewW - sceneWidth;
      return Math.min(0, Math.max(minX, nx));
    }

    function setPan(nx) {
      currentX = clampPan(nx);
      pan.style.transform = `translateX(${currentX}px)`;
    }

    window.addEventListener("wheel", e => {
      e.preventDefault();
      x = clampPan(x - e.deltaY);
      setPan(x);
    }, { passive: false });

    window.addEventListener("touchstart", e => {
      dragging = true;
      startX = e.touches[0].clientX;
    }, { passive: true });

    window.addEventListener("touchmove", e => {
      if (!dragging) return;
      setPan(x + (e.touches[0].clientX - startX));
    }, { passive: true });

    window.addEventListener("touchend", e => {
      if (!dragging) return;
      x = clampPan(x + (e.changedTouches[0].clientX - startX));
      setPan(x);
      dragging = false;
    });

    let particles = [];
    const BASE_COUNT = 150;
    const MAX_COUNT = 1500;

    function initParticles() {
      // ðŸ”‘ critical fix: block bad spawn window
      if (!sceneWidth || sceneWidth <= viewW) return;

      const count = Math.min(
        MAX_COUNT,
        Math.max(BASE_COUNT, Math.round(BASE_COUNT * (sceneWidth / viewW)))
      );

      particles = Array.from({ length: count }, () => ({
        x: Math.random() * sceneWidth,
        y: Math.random() * viewH,
        r: Math.random() * 2 + 1,
        d: Math.random() * 1 + 0.5
      }));
    }

    function resizeAll() {
      viewW = window.innerWidth;
      viewH = window.innerHeight;

      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.round(viewW * dpr);
      canvas.height = Math.round(viewH * dpr);
      canvas.style.width  = viewW + "px";
      canvas.style.height = viewH + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      measureSceneWidth();

      x = clampPan(x);
      setPan(x);

      // ðŸ”‘ kill any bad leftovers
      particles.length = 0;
      initParticles();
    }

    window.addEventListener("resize", resizeAll);

    function drawSnow() {
      ctx.clearRect(0, 0, viewW, viewH);
      ctx.fillStyle = "white";
      ctx.beginPath();

      const margin = 10;

      for (const p of particles) {
        const sx = p.x + currentX;

        if (sx >= -margin && sx <= viewW + margin) {
          ctx.moveTo(sx, p.y);
          ctx.arc(sx, p.y, p.r, 0, Math.PI * 2);
        }

        p.y += p.d;

        if (p.y > viewH + margin) {
          p.y = -margin;
          p.x = Math.random() * sceneWidth;
        }
      }

      ctx.fill();
      requestAnimationFrame(drawSnow);
    }

    function start() {
      requestAnimationFrame(() => {
        resizeAll();
        drawSnow();
      });
    }

    if (img.complete && img.naturalWidth) start();
    else img.addEventListener("load", start);
  </script>

</body>
</html>
